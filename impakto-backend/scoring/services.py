# impakto-backend/scoring/services.py

from django.db.models import Sum, Count, Avg, StdDev, Q
from django.utils import timezone
from datetime import timedelta
from ledger.models import Activity

class TrustScoringService:
    """
    Service layer dedicated to computing real-time alternative credit metrics.
    Decouples complex algorithmic logic from the API routing layer.
    """
    
    TARGET_MONTHLY_ACTIVITY = 15.0
    BASE_SCORE = 300
    SCORE_RANGE = 550
    
    # Weight configuration based on systemic importance
    WEIGHTS = {
        'consistency': 0.35,
        'stability': 0.40,
        'verification': 0.25
    }

    @classmethod
    def calculate_trust_signals(cls, user_id: int) -> dict:
        """
        Computes the Consistency Index, Revenue Stability Index, and overall Trust Score
        for a given user based on a rolling 30-day window.
        """
        start_date = timezone.now() - timedelta(days=30)
        
        # 1. Fetch temporal activity window
        activities = Activity.objects.filter(
            user_id=user_id,
            timestamp__gte=start_date
        )
        
        # 2. Database-level Aggregations
        aggregates = activities.aggregate(
            total_count=Count('id'),
            verified_count=Count('id', filter=Q(is_verified=True)),
            total_volume=Sum('amount'),
            mean_amount=Avg('amount'),
            stddev_amount=StdDev('amount')
        )
        
        # Coalesce null values generated by empty querysets
        total_count = aggregates['total_count'] or 0
        verified_count = aggregates['verified_count'] or 0
        mean_amount = aggregates['mean_amount'] or 0.0
        stddev_amount = aggregates['stddev_amount'] or 0.0
        total_volume = aggregates['total_volume'] or 0.0

        # 3. Calculate Consistency Index (CI)
        consistency_index = min(total_count / cls.TARGET_MONTHLY_ACTIVITY, 1.0)
        
        # 4. Calculate Revenue Stability Index (SI) using Coefficient of Variation (CV)
        # Bounded against the cold start problem (N < 2 implies no calculable variance)
        if mean_amount > 0 and total_count > 1:
            coefficient_of_variation = stddev_amount / mean_amount
            stability_index = max(0.0, 1.0 - coefficient_of_variation)
        else:
            stability_index = 0.0
            
        # 5. Calculate Verification Strength Index (VI)
        verification_index = (verified_count / total_count) if total_count > 0 else 0.0
        
        # 6. Compute Composite Trust Score
        composite_ratio = (
            (cls.WEIGHTS['consistency'] * consistency_index) +
            (cls.WEIGHTS['stability'] * stability_index) +
            (cls.WEIGHTS['verification'] * verification_index)
        )
        
        trust_score = int(cls.BASE_SCORE + (composite_ratio * cls.SCORE_RANGE))
        
        return {
            "overall_score": trust_score,
            "consistency_index": float(consistency_index),
            "stability_index": float(stability_index),
            "verification_index": float(verification_index),
            "total_volume": float(total_volume),
            "activity_count": int(total_count)
        }